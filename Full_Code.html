<!DOCTYPE html>
<!-- Le code javascript se trouve plus bas -->
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0">
    <style>
        *{
            box-sizing: border-box;
            padding: 0;
            margin: 0;
            touch-action: none;
            -webkit-user-select: none; /* Safari */        
            -moz-user-select: none; /* Firefox */
            -ms-user-select: none; /* IE10+/Edge */
            user-select: none; /* Standard */
        }
        body {
            
            overflow: hidden;
            position: fixed;
            /* display: flex;
            justify-content: center; */
            background: rgb(2,0,36);
            background: linear-gradient(140deg, rgb(202, 246, 223) 10%, rgba(0,212,255,1) 100%) fixed;
        }

        .container {
            display: grid;
            grid-template-columns: 65% auto;
            grid-template-rows: 75% auto;
            grid-template-areas:
                "perspective flatview"
                "controls controls";
            width: 100vw;
            height: 100vh;
        }
        .controls {
            display:flex;
            flex-direction: row;
            flex-wrap: wrap;
            justify-content: space-evenly;
            align-items: flex-start;
            padding-top: 30px;

            background-color: rgb(202, 202, 202);
            grid-area: controls;
        }
        .perspective {
            display:flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding-left: 5px;
            padding-right: 5px;

            background-color: rgb(0, 110, 255);
            grid-area: perspective;
        }
        .flatview { 
            display:flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding:5px;

            background-color: rgb(0, 110, 255);
            grid-area: flatview;
        } 
        #canvas3D {
            width: 100%;
            height: auto;
            background:rgb(56, 56, 56);
        }
        #canvas2D {
            width: 100%;
            height: auto;
            background:rgb(56, 56, 56);
        }

        .instructions {
            font-family:'Trebuchet MS', 'Lucida Sans Unicode', 'Lucida Grande', 'Lucida Sans', Arial, sans-serif;
            font-size:large;
        }
        .sceneSettings {
            display: flex;
            flex-direction: column;
        }
        .wallOptions {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .toggles {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

    </style>
    <title>Raycasting</title>
</head>
<body>
    <div class="container">
        <div class="perspective">
            <canvas id="canvas3D"></canvas>
        </div>
        <div class="flatview">
            <p class="instructions">Click and drag to draw walls</p>
            <canvas id="canvas2D"></canvas>
        </div>
        <div class="controls" id="booger">
            <p class="instructions"> Use W A S D to move <br>
                Use the arrow keys to look around <br>
                If using a touch screen, tap the
                colored boxes for controls
            </p>
            <div class="toggles">
                <button onclick="show2D2 = !show2D2">Toggle Advanced 2D view</button>
                <button onclick="rainbowMode = !rainbowMode">Toggle Rainbow mode</button>
            </div>
            <div class="wallOptions">
                Wall color <input type="color" value="#ff0000" id="colorpick">
            </div>
            <div class="sceneSettings">
                <button onclick="undoWall = true">Undo new Wall</button>
                <button onclick="
                                renderWalls.splice(0, renderWalls.length);
                                walls.splice(0, walls.length);
                                wallCount = 0;
                                ">Reset all Walls</button>
                <button onclick="exampleScene()">Generate example scene</button>
                <button onclick="showWallNums = !showWallNums">Toggle Wall numbers</button>
            </div>
        </div>
    </div>
    <script>
        function radians(degreeValue) {
            return degreeValue * (Math.PI / 180);
        }

        function degrees(radianValue) {
            return radianValue * (180 / Math.PI);
        }

        function circle(x, y, r, fill = "white", lineWidth = 1, lineColor = fill) {
            ctx.beginPath();
            ctx.fillStyle = fill;
            ctx.lineWidth = lineWidth;
            ctx.strokeStyle = lineColor;
            ctx.arc(x, y, r, 0, 2 * Math.PI);
            ctx.stroke();
            ctx.fill();
        }

        function ellipse(x, y, r1, r2 = r1, fill = "white", lineWidth = 1, lineColor = fill) {
            ctx.beginPath();
            ctx.fillStyle = fill;
            ctx.lineWidth = lineWidth;
            ctx.strokeStyle = lineColor;
            ctx.ellipse(x, y, r1, r2, 0, 0, 2 * Math.PI);
            ctx.stroke();
            ctx.fill();
        }

        function line(x1, y1, x2, y2, lineColor = 'white', lineWidth = 1) {
            ctx.beginPath();
            ctx.lineWidth = lineWidth;
            ctx.strokeStyle = lineColor;
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.stroke();
        }

        function polygon(coords, fill = "white", lineWidth = 1, lineColor = fill) {
            if (coords.length % 2 != 0) {
                console.warn('undefined number of args when drawing polygon');
                return;
            }
            ctx.save();
            ctx.beginPath();
            ctx.moveTo(coords[0], coords[1]);
            for (let i = 2; i < coords.length; i += 2) {
                ctx.lineTo(coords[i], coords[i + 1]);
            }
            ctx.closePath();
            ctx.fillStyle = fill;
            ctx.lineWidth = lineWidth;
            ctx.strokeStyle = lineColor;
            ctx.stroke();
            ctx.fill();
            ctx.restore();
            return coords;
        }


        function getRotation(pos, header) {
            let rotation = Math.abs(Math.atan(header.y / header.x));
            const x = pos.x;
            const y = pos.y;
            const x2 = pos.x + header.x;
            const y2 = pos.y + header.y;
            if (x2 > x && y2 >= y) rotation = rotation; //Q1  no change
            if (x2 <= x && y2 > y) rotation = Math.PI - rotation; //Q2  add 90 degrees
            if (x2 < x && y2 <= y) rotation += Math.PI;
            if (x2 >= x && y2 < y) rotation = Math.PI * 2 - rotation;
            return rotation;
        }


        // for choosing the color of the walls
        // https://www.html-code-generator.com/javascript/color-converter-script
        function HEXtoHSL(hex) {
            hex = hex.replace(/#/g, '');
            if (hex.length === 3) {
                hex = hex.split('').map(function (hex) {
                    return hex + hex;
                }).join('');
            }
            var result = /^([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})[\da-z]{0,0}$/i.exec(hex);
            if (!result) {
                return null;
            }
            var r = parseInt(result[1], 16);
            var g = parseInt(result[2], 16);
            var b = parseInt(result[3], 16);
            r /= 255, g /= 255, b /= 255;
            var max = Math.max(r, g, b),
                min = Math.min(r, g, b);
            var h, s, l = (max + min) / 2;
            if (max == min) {
                h = s = 0;
            } else {
                var d = max - min;
                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                switch (max) {
                    case r:
                        h = (g - b) / d + (g < b ? 6 : 0);
                        break;
                    case g:
                        h = (b - r) / d + 2;
                        break;
                    case b:
                        h = (r - g) / d + 4;
                        break;
                }
                h /= 6;
            }
            s = s * 100;
            s = Math.round(s);
            l = l * 100;
            l = Math.round(l);
            h = Math.round(360 * h);

            return {
                h: h,
                s: s,
                l: l
            };
        }

        let canvas = document.getElementById('canvas3D');
        let ctx = canvas.getContext('2d', { alpha: false });

        const canvas2D = document.getElementById("canvas2D");
        const ctx2D = canvas2D.getContext("2d", { alpha: false });

        function set2Dctx() {
            ctx = canvas2D.getContext("2d", { alpha: false });
        }
        function set3Dctx() {
            ctx = canvas.getContext('2d', { alpha: false });
        }

        const cooldown = 15
        let currentCooldown = cooldown;
        let undoWall = false;

        const keysPressed = {};

        const mouse = {
            'x': undefined,
            'y': undefined
        };

        const handlers = {
            click(e) {
                mouse.x = e.offsetX;
                mouse.y = canvas2D.height - e.offsetY;
                drawing.startpos.x = mouse.x;
                drawing.startpos.y = mouse.y;
                e.preventDefault();
                drawing.isDrawing = true;
            },
            unclick(e) {
                e.preventDefault();
                document.activeElement.blur();
                drawing.stop();
            },
            updateCanvasSize() {
                canvas.height = canvas.offsetHeight;
                canvas.width = canvas.offsetWidth;
                canvas2D.height = canvas2D.offsetWidth;
                canvas2D.width = canvas2D.offsetWidth;
                // console.log(canvas.height, canvas.width);
            }
        };



        const drawing = {
            isDrawing: false,
            startpos: {
                'x': undefined,
                'y': undefined
            },
            start() {
                if (currentCooldown <= 0) currentCooldown = cooldown;
                if (currentCooldown > 0 && currentCooldown < cooldown) currentCooldown--;
                if (!this.isDrawing) {
                    if ((undoWall || (keysPressed.Control && keysPressed.z)) && currentCooldown == cooldown && walls.length > 0) {  // Remove latest wall
                        console.log("undioing") // TEST
                        currentCooldown = cooldown - 1;
                        wallCount--;
                        walls.pop();
                    }
                    undoWall = false;
                    if (mouse.x < canvas2D.width && mouse.x > 0 && mouse.y < canvas2D.height && mouse.y > 0) {
                        this.startpos.x = mouse.x;
                        this.startpos.y = mouse.y;
                    } else {
                        return;
                    }
                }
                if (this.isDrawing && (mouse.x < canvas2D.width && mouse.x > 0 && mouse.y < canvas2D.height && mouse.y > 0)) {
                    set2Dctx();
                    line(this.startpos.x, this.startpos.y, mouse.x, mouse.y);
                    set3Dctx();
                }
            },
            stop() {
                if (this.isDrawing && (Math.abs(this.startpos.x - mouse.x) > 10 || Math.abs(this.startpos.y - mouse.y) > 10)) {
                    newWall = {
                        "pos": {
                            "x": this.startpos.x,
                            "y": this.startpos.y
                        },
                        "header": {
                            "x": mouse.x - this.startpos.x,
                            "y": mouse.y - this.startpos.y
                        }
                    }
                    let intCount = 0;
                    walls.forEach(wall => {
                        if (isIntersectionVectors(wall, newWall)) {
                            intCount++;
                        };
                    });
                    if (intCount == 0) {
                        walls.push(new Boundary(this.startpos.x, this.startpos.y,
                            mouse.x, mouse.y,
                            HEXtoHSL(document.getElementById("colorpick").value).h));
                    }
                }
                this.isDrawing = false;
            }
        };

        document.addEventListener('resize', handlers.updateCanvasSize());
        document.onkeyup = (e) => delete keysPressed[e.key];
        document.onkeydown = (e) => (keysPressed[e.key] = true);

        document.ondblclick = (e) => e.preventDefault();

        canvas2D.addEventListener("pointermove", (e) => {
            e.preventDefault();
            mouse.x = e.offsetX;
            mouse.y = canvas2D.height - e.offsetY;
        });
        canvas2D.addEventListener("pointerdown", (e) => handlers.click(e));
        document.addEventListener('pointerup', (e) => handlers.unclick(e));

        class Button {
            constructor(x, y, width, height, color, char = "boop") {
                this.active = false;
                this.color = color;
                this.height = height;
                this.width = width;
                this.x = x;
                this.y = y;
                this.char = char
            }

            draw() {
                let tmpalpha = ctx.globalAlpha;
                ctx.globalAlpha = 0.1;
                polygon([this.x, this.y,
                this.x, this.y + this.height,
                this.x + this.width, this.y + this.height,
                this.x + this.width, this.y], this.color)
                ctx.save();
                ctx.setTransform(1, 0, 0, 1, 0, 0);
                ctx.font = "bolder 30px Arial";
                ctx.textAlign = "center";
                ctx.textBaseline = 'middle';
                ctx.fillStyle = "black";
                ctx.fillText(this.char, this.x + this.width / 2, canvas.height - this.y - this.height / 2);
                ctx.restore();
                ctx.globalAlpha = tmpalpha;
            }

            containsPoint(x, y) {
                // if the point is outside of the rectangle return false:
                return (x < this.x ||
                    x > this.x + this.width ||
                    y < this.y ||
                    y > this.y + this.width);
            }
        }

        const pointer = {
            'x': undefined,
            'y': undefined
        };
        let isPointing = false;
        const isTouchScreen = window.matchMedia("(pointer: coarse)").matches
        if (isTouchScreen) {
            canvas3D.addEventListener("pointerdown", (e) => {
                isPointing = true;
                pointer.x = e.offsetX;
                pointer.y = canvas.height - e.offsetY;
                e.preventDefault();
            });

            canvas3D.addEventListener("pointermove", (e) => {
                e.preventDefault();
                pointer.x = e.offsetX;
                pointer.y = canvas.height - e.offsetY;
            });
            canvas3D.addEventListener("pointerup", (e) => {
                isPointing = false;
                e.preventDefault();
                for (let button of buttons) {
                    button.active = false;
                }
            });
        }



        let W = canvas.width / 6
        let H = canvas.height / 4
        let buttons = [
            new Button(0, 0, W, H, "yellow", "A"),
            new Button(2 * W, 0, W, H, "green", "D"),
            new Button(W, 0, W, H, "cyan", "S"),
            new Button(W, H, W, H, "orange", "W"),
            new Button(3 * W, 0, W, H, "yellow", "⇦"),
            new Button(5 * W, 0, W, H, "green", "⇨")
        ]

        function touchControls() {
            if (isTouchScreen) {
                renderButtons();
                if (isPointing) detectButtons();
                handleButtons();
            }
        }



        function renderButtons() {
            for (let button of buttons) {
                button.draw();
            }
        }
        function detectButtons() {
            for (let button of buttons) {
                button.active = false;
                if (
                    pointer.x > button.x && pointer.x < button.x + button.width &&
                    pointer.y > button.y && pointer.y < button.y + button.height) {
                    button.active = true;
                    break;
                }
            }
        }

        function handleButtons() {
            if (buttons[0].active) {
                keysPressed.a = true;
            } else {
                keysPressed.a = false;
            }
            if (buttons[2].active) {
                keysPressed.s = true;
            } else {
                keysPressed.s = false;
            }
            if (buttons[1].active) {
                keysPressed.d = true;
            } else {
                keysPressed.d = false;
            }
            if (buttons[3].active) {
                keysPressed.w = true;
            } else {
                keysPressed.w = false;
            }

            if (buttons[4].active) {
                keysPressed.ArrowLeft = true;
            } else {
                keysPressed.ArrowLeft = false;
            }
            if (buttons[5].active) {
                keysPressed.ArrowRight = true;
            } else {
                keysPressed.ArrowRight = false;
            }
        }
        class Ray {
            constructor(x, y, rotation, length = 200) {
                this.pos = {
                    'x': x,
                    'y': y
                };
                this.header = {
                    'x': Math.cos(radians(rotation)),
                    'y': Math.sin(radians(rotation)),
                    'length': length
                };
            }
            draw(COLOR, lineWidth = 1) { // 2D
                line(this.pos.x, this.pos.y, this.pos.x + this.header.x * this.header.length, this.pos.y + this.header.y * this.header.length, COLOR, lineWidth);
            }
            setAngle(angle) { //input is in degrees but handled in radians
                this.header.x = Math.cos(radians(angle));
                this.header.y = Math.sin(radians(angle));
            }
        }

        class Player {
            constructor(x, y, rotation) {
                this.rotation = radians(rotation); //input is in degrees but handled in radians
                this.vertRotation = 0;

                this.height = 180; // height is in cm

                this.farSight = 1000
                this.moveStep = 2;
                this.lookStepH = 2;
                this.lookStepV = 5;
                this.pos = {
                    'x': x,
                    'y': y
                };
                this.header = {
                    'x': Math.cos(this.rotation),
                    'y': Math.sin(this.rotation),
                    'length': this.moveStep
                };

                this.fov = {
                    'xamount': 235,  //based on human eyes 235 degrees
                    'yamount': 280
                };
                this.fov.v1 = new Ray(this.pos.x, this.pos.y, degrees(this.rotation) + this.fov.xamount / 2, this.farSight);
                this.fov.v2 = new Ray(this.pos.x, this.pos.y, degrees(this.rotation) - this.fov.xamount / 2, this.farSight);
            }

            draw() {
                // ctx.fillStyle = 'white';
                // ctx.fillRect(this.pos.x - 5, this.pos.y - 5, 10, 10);

                ellipse(this.pos.x, this.pos.y, 7, 7, "orange");

                // line(this.pos.x, this.pos.y, this.pos.x + (this.header.x) * 100, this.pos.y + (this.header.y) * 100, 'white', 1);

                this.fov.v1.draw('orange', 3); // green

                this.fov.v2.draw("orange", 3); // green
            }



            setAngle(angle) { //input is in degrees but handled in radians
                this.rotation = radians(angle);
                if (this.rotation > 2 * Math.PI) this.rotation -= 2 * Math.PI;
                if (this.rotation < -2 * Math.PI) this.rotation += 2 * Math.PI;
                this.setFOV();
                this.header.x = Math.cos(this.rotation);
                this.header.y = Math.sin(this.rotation);
            }
            sideLook(angle) { //input is in degrees but handled in radians
                this.setAngle(degrees(this.rotation) + angle);
            }
            verticalLook(angle) {
                let vertLimit = {};
                vertLimit.max = this.fov.yamount;
                vertLimit.min = -this.fov.yamount;
                if (this.vertRotation + angle >= vertLimit.min && this.vertRotation + angle <= vertLimit.max) {
                    this.vertRotation += angle;
                    ctx.translate(0, angle);
                }
            }
            sideMove(step) {
                this.pos.x += -step * this.header.y;
                this.pos.y += step * this.header.x;
                this.setFOV();
            }
            straightMove(step) {
                this.pos.x = this.pos.x + step * this.header.x;
                this.pos.y = this.pos.y + step * this.header.y;
                this.setFOV();
            }

            setFOV() {
                this.fov.v1.setAngle(degrees(this.rotation) + this.fov.xamount / 2);
                this.fov.v2.setAngle(degrees(this.rotation) - this.fov.xamount / 2);
                this.fov.v1.pos = this.pos;
                this.fov.v2.pos = this.pos;
            }
        }

        const playerHandler = {
            movement() {
                if (keysPressed.w) {
                    player.straightMove(player.moveStep);
                }
                if (keysPressed.s) {
                    player.straightMove(-player.moveStep);
                }
                if (keysPressed.a) {
                    player.sideMove(player.moveStep);
                }
                if (keysPressed.d) {
                    player.sideMove(-player.moveStep);
                }
                if (keysPressed.ArrowUp) {
                    player.verticalLook(-player.lookStepV);
                }
                if (keysPressed.ArrowDown) {
                    player.verticalLook(player.lookStepV);
                }
                if (keysPressed.ArrowLeft) {
                    player.sideLook(player.lookStepH);
                }
                if (keysPressed.ArrowRight) {
                    player.sideLook(-player.lookStepH);
                }
            }
        };
        class Boundary {
            constructor(x1, y1, x2, y2, hue="100", opacity=1, height0=0, height1=500) {
                // console.log(Math.round(x1), Math.round(y1), Math.round(x2), Math.round(y2));
                this.pos = {
                    'x': x1,
                    'y': y1
                };
                this.header = {
                    'x': x2 - x1,
                    'y': y2 - y1,
                };
                wallCount++;
                this.index = wallCount -1;
                this.length = Math.sqrt((this.header.x) * (this.header.x) + (this.header.y) * (this.header.y));

                this.rotation = getRotation(this.pos, this.header);
                this.hue = hue; //colorpicker element in main.js
                this.opacity = opacity;

                this.height0 = height0;
                this.height1 = height1;

                
            }

            draw() {
                set2Dctx();
                line(this.pos.x, this.pos.y, this.pos.x + this.header.x, this.pos.y + this.header.y, "hsl(" + this.hue + ", 100%, 50%)", 3);
                ellipse(this.pos.x, this.pos.y, 5, 5, 'green');
                ellipse(this.pos.x + this.header.x, this.pos.y + this.header.y, 5, 5, 'red');
                // ellipse(this.pos.x, this.pos.y, 2, 2, 'white');  // green
                // ellipse(this.pos.x + this.header.x, this.pos.y + this.header.y, 2, 2, 'white'); // red
                if (showWallNums) {
                    ctx.save();
                    ctx.setTransform(1, 0, 0, 1, 0, 0);
                    ctx.font = "30px Arial";
                    ctx.fillStyle = 'white';
                    ctx.fillText(this.index, (this.pos.x*2 + this.header.x)/2 - 10, canvas2D.height - (this.pos.y*2 + this.header.y)/2 - 10);
                    ctx.restore();
                }
                set3Dctx();
            }

            isInsideFOV() {
                this.p = {  // Creating vector going from player to wall's first vertex
                    'x': this.pos.x - player.pos.x,
                    'y': this.pos.y - player.pos.y
                };

                this.h = {  // Creating vector going from player to wall's first vertex
                    'x': (this.pos.x + this.header.x) - player.pos.x,
                    'y': (this.pos.y + this.header.y) - player.pos.y
                };

                if ((isIntersectionFovW(player.fov.v1, this) || isIntersectionFovW(player.fov.v2, this)) ||
                    (isClockwiseOrder(player.fov.v1.header, this.p) && !isClockwiseOrder(player.fov.v2.header, this.p) &&
                    isClockwiseOrder(player.fov.v1.header, this.h) && !isClockwiseOrder(player.fov.v2.header, this.h))
                ) return true;
            }

            processFOV() {
                // make sure v1 is always to the left of v2
                if (!isClockwiseOrder(this.p, this.h)) {
                    let vtemp = this.p;
                    this.p = this.h;
                    this.h = vtemp;
                }

                //  redefine wall if it intersects with LEFT fov ray
                if (!isClockwiseOrder(player.fov.v1.header, this.p) && isClockwiseOrder(player.fov.v1.header, this.h)) {
                    this.p = intersectionFovW(player.fov.v1, this);
                    this.p.x -= player.pos.x;
                    this.p.y -= player.pos.y;
                }

                //  redefine wall if it intersects with RIGHT fov ray
                if (!isClockwiseOrder(player.fov.v2.header, this.p) && isClockwiseOrder(player.fov.v2.header, this.h)) {
                    this.h = intersectionFovW(player.fov.v2, this);
                    this.h.x -= player.pos.x;
                    this.h.y -= player.pos.y;
                }
                this.p.dist = Math.sqrt((this.p.x) ** 2 + (this.p.y) ** 2);
                this.h.dist = Math.sqrt((this.h.x) ** 2 + (this.h.y) ** 2);

                // debugging  2D Representation
                if (show2D2) {
                    set2Dctx();
                    ellipse(player.pos.x + this.p.x, player.pos.y + this.p.y, 10, 10, 'yellow');
                    line(player.pos.x, player.pos.y, player.pos.x + this.p.x, player.pos.y + this.p.y, 'purple', 5);
                    ellipse(player.pos.x + this.h.x, player.pos.y + this.h.y, 10, 10, 'cyan');
                    line(player.pos.x, player.pos.y, player.pos.x + this.h.x, player.pos.y + this.h.y, 'purple', 5);
                    set3Dctx();
                }
                return true;
            }

            calculate3D() {
                const fovamount = player.fov.xamount;

                this.p = vectorNormalize(this.p);
                this.h = vectorNormalize(this.h);
                const header = vectorNormalize(player.header, Math.sqrt((player.header.y) ** 2 + (player.header.x) ** 2));

                let v1xangle = Math.acos(vectorDotProduct(this.p, header));        // get angle between header and v1   vectors are normalized so the dotproduct will give a value between -1 and 1
                let v2xangle = Math.acos(vectorDotProduct(this.h, this.p));       // get angle between v1 and v2
                                                                                    // angles are calculated using | adjacent / hypothenuse
                                                                                    // hypothenuse is 1 because v1/v1 was normalized (no denominator)
                                                                                    // adjacent is v1/v1 projected onto the header for the adjacent side of the triangle (or relative to the other v1/v2)

                if (!isClockwiseOrder(header, this.p)) v1xangle = -v1xangle;  // correct sign depending on side of v1/v2
                if (!isClockwiseOrder(this.p, this.h)) v2xangle = -v2xangle;

                v2xangle = v2xangle + v1xangle; // make v2 relative to v1

                this.x1 = degrees(v1xangle) * canvas.width / fovamount;
                this.h1 = this.calculateHeight(this.p);

                this.x2 = degrees(v2xangle) * canvas.width / fovamount;
                this.h2 = this.calculateHeight(this.h);
            }

            //works by supposing a 2d side view of the player looking at the wall and using trigonometry to find the angle of the top and bottom of the wall
            calculateHeight(v) {
                const header = vectorCreate(v.dist, 0);
                const h0 = vectorCreate(v.dist, this.height0 - player.height);
                const h1 = vectorCreate(v.dist, this.height1 - player.height);
                
                const floor = vectorCreate(v.dist, -player.height);
                let floorAngle =    Math.acos((vectorDotProduct(header, floor)) / (vectorDist(floor.x, floor.y) * v.dist));
                
                let anglev1 =       Math.acos((vectorDotProduct(header, h0)) / (vectorDist(h0.x, h0.y) * v.dist));
                let anglev2 = Math.acos((vectorDotProduct(header, h1)) / (vectorDist(h1.x, h1.y) * v.dist));

                if (isClockwiseOrder(header, floorAngle)) floorAngle = -floorAngle;
                if (isClockwiseOrder(header, h0)) anglev1 = -anglev1;
                if (isClockwiseOrder(header, h1)) anglev2 = -anglev2;
                if (floorAngle == anglev1) console.log("aa")
                return {
                    'floor': 1 * degrees(floorAngle) * canvas.height / player.fov.yamount * 2,
                    'h0': 1 * degrees(anglev1) * canvas.height / player.fov.yamount * 2,
                    'h1': 1 * degrees(anglev2) * canvas.height / player.fov.yamount * 2,
                    'sat': 1,
                    'dist': v.dist
                };
            }
            display3D() {
                const minh = 25;
                const maxh = 50;
                const ver = maxh - minh;
                const hor = 450;
                const a = -ver/hor;
                // function determined with https://math.stackexchange.com/questions/2170013/looking-for-a-decreasing-function-which-initially-decreases-slowly-and-then-decr
                let L1 = this.p.dist * a + maxh;
                if (L1 < minh) L1 = minh;
                if (L1 > maxh) L1 = maxh;

                let L2 = this.h.dist * a + maxh;
                if (L2 < minh) L2 = minh;
                if (L2 > maxh) L2 = maxh;

                // if (!this.x1 || !this.x2) {console.log("aha"); return; }
                const grd = ctx.createLinearGradient(this.x1 + canvas.width / 2, canvas.height / 2,
                            this.x2 + canvas.width / 2, canvas.height / 2);

                grd.addColorStop(0, `hsla(${this.hue}, 100%, ${L1}%, 1)`);
                grd.addColorStop(1, `hsla(${this.hue}, 100%, ${L2}%, 1)`);
                ctx.fillStyle = grd;
                
                let tmpalpha = ctx.globalAlpha;
                ctx.globalAlpha = this.opacity;
                
                polygon([   this.x1 + canvas.width / 2, this.h1.floor + canvas.height /2,
                        this.x2 + canvas.width / 2, this.h2.floor + canvas.height /2,
                        this.x2 + canvas.width / 2, this.h2.floor - canvas.height,
                        this.x1 + canvas.width / 2, this.h1.floor - canvas.height,
                ], "#969696", 0); // `hsla(1, 50%, 50%, 0.5)`s

                polygon([this.x1 + canvas.width / 2, this.h1.h0 + canvas.height / 2,
                this.x1 + canvas.width / 2, this.h1.h1 + canvas.height /2,
                this.x2 + canvas.width / 2, this.h2.h1 + canvas.height /2,
                this.x2 + canvas.width / 2, this.h2.h0 + canvas.height /2
                ], `grd`, 2); // `hsla(1, 50%, 50%, 0.5)`

                ctx.globalAlpha = tmpalpha;
            }
            setAngle(angle) {
                this.header.x = Math.cos(angle) * this.length;
                this.header.y = Math.sin(angle) * this.length;
                this.rotation = getRotation(this.pos, this.header);
            }
        }
        function isClockwiseOrder(v1, v2) {  // Tests if the cross product with z=0, returns positive or negative (clockwise or anticlockwise)
            // const crossProduct = v1.x*v2.y - v1.y*v2.x;
            return v1.x * v2.y - v1.y * v2.x <= 0;
        }

        function vectorDist(x, y) { // returns distance of a vector
            return Math.sqrt(x ** 2 + y ** 2);
        }

        function vectorDotProduct(v1, v2) {
            // const dot = v1.x*v2.x + v1.y*v2.y;
            return v1.x * v2.x + v1.y * v2.y;
        }

        function vectorCreate(headerx, headery) {
            return {
                'x': headerx,
                'y': headery
            };
        }

        function vectorNormalize(v, dist = v.dist) {
            v.x = v.x / dist;
            v.y = v.y / dist;
            return v;
        }

        function vectorAdd(A, B) {
            return {
                "x": A.x + B.x,
                "y": A.y + B.y
            }
        }
        function isIntersectionVectors(v1, v2) {
            const x1 = v1.pos.x;
            const y1 = v1.pos.y;
            const x2 = x1 + v1.header.x;
            const y2 = y1 + v1.header.y;

            const x3 = v2.pos.x;
            const y3 = v2.pos.y;
            const x4 = x3 + v2.header.x;
            const y4 = y3 + v2.header.y;

            const den = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
            if (den == 0) return false;
            const t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / den;
            const u = -((x1 - x2) * (y1 - y3) - (y1 - y2) * (x1 - x3)) / den;

            // if t and u are between 0 and 1 then the intersection falls between v1 and v2
            return u >= 0 && u <= 1 && t >= 0 && t <= 1;
        }

        function intersectionVectors(v1, v2) {
            if (!isIntersectionVectors(v1, v2)) return;

            const x1 = v1.pos.x;
            const y1 = v1.pos.y;
            const x2 = x1 + v1.header.x;
            const y2 = y1 + v1.header.y;

            const x3 = v2.pos.x;
            const y3 = v2.pos.y;
            const x4 = x3 + v2.header.x;
            const y4 = y3 + v2.header.y;

            const den = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
            const u = ((x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)) / den;

            const xint = x3 + u * (x4 - x3);
            const yint = y3 + u * (y4 - y3);
            const intersection = {
                'x': xint,
                'y': yint,
                'dist': Math.sqrt((y1 - yint) ** 2 + (x1 - xint) ** 2)
            };
            return intersection;
        }

        // condensed version of intersection() but only the conditional
        function isIntersectionFovW(w1, w2) {
            const x1 = w1.pos.x; // meant for fov rays
            const y1 = w1.pos.y;
            const x2 = x1 + w1.header.x * w1.header.length;
            const y2 = y1 + w1.header.y * w1.header.length;

            const x3 = w2.pos.x; // meant for wall objects
            const y3 = w2.pos.y;
            const x4 = x3 + w2.header.x;
            const y4 = y3 + w2.header.y;

            const den = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
            if (den == 0) return false;
            const t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / den;
            const u = -((x1 - x2) * (y1 - y3) - (y1 - y2) * (x1 - x3)) / den;

            // if t and u are between 0 and 1 then the intersection falls between v1 and v2
            return u >= 0 && u <= 1 && t >= 0 && t <= 1;
        }

        function intersectionFovW(w1, w2) {
            if (!isIntersectionFovW(w1, w2)) return;

            const x1 = w1.pos.x;
            const y1 = w1.pos.y;
            const x2 = x1 + w1.header.x * w1.header.length;
            const y2 = y1 + w1.header.y * w1.header.length;

            const x3 = w2.pos.x;
            const y3 = w2.pos.y;
            const x4 = x3 + w2.header.x;
            const y4 = y3 + w2.header.y;

            const den = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
            const u = ((x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)) / den;

            const xint = x3 + u * (x4 - x3);
            const yint = y3 + u * (y4 - y3);
            const intersection = {
                'x': xint,
                'y': yint,
                'dist': Math.sqrt((y1 - yint) ** 2 + (x1 - xint) ** 2)
            };
            return intersection;
        }
        class Graph {
            constructor() {
                this.adjacencyList = new Map();
                this.edges = []
            }

            // add vertex to the graph
            addVertex(vertex) {
                if (!this.adjacencyList.get(vertex)) {
                    this.adjacencyList.set(vertex, []);
                }
            }

            // add edge to the graph
            addEdge(source, destination) {
                if (!this.adjacencyList.get(source)) {
                    this.addVertex(source);
                }
                if (!this.adjacencyList.get(destination)) {
                    this.addVertex(destination);
                }
                this.edges.push([source, destination])
                this.adjacencyList.get(source).push(destination);
            }

            // Prints the vertex and adjacency list
            printGraph() {
                // get all the vertices
                var get_keys = this.adjacencyList.keys();
                let final = "";
                // iterate over the vertices
                for (var i of get_keys) {
                    // get the corresponding adjacency list for the vertex
                    var get_values = this.adjacencyList.get(i);
                    var conc = "";

                    // iterate over the adjacency list and concatenate the values into a string
                    for (var j of get_values) {
                        conc += j + " ";
                    }
                    // print the vertex and its adjacency list
                    final = final + i + " -> " + conc + "\n";
                }
                if (showGraph) {
                    console.log(final);
                    showGraph = false;
                }
            }

            /*/ // // Non-recursive DFS // // /*/
            topologicalSort() {
                let G = this.adjacencyList
                let distance = new Map();
                for (let v of G.keys()) {
                    if (!distance.has(v)) {
                        distance.set(v, 0);
                        this.dfs(v, distance, G)
                    }
                }
                // console.log(distance)
                let vertices = []
                let i = 0;
                while (distance.size > 0) {
                    for (let v of G.keys()) {
                        if (distance.get(v) == i) {
                            vertices.push(v)
                            distance.delete(v)
                        }
                    }
                    i += 1
                }
                return vertices;
            }
            dfs(s, distance, G) {
                let counter = new Map();
                let nodes_to_visit = [s]

                while (nodes_to_visit.length > 0) {
                    let currentnode = nodes_to_visit.shift();
                    if (counter.has(currentnode)) {
                        let curcount = counter.get(currentnode);
                        counter.set(currentnode, curcount + 1)
                        if (curcount > 1000) {
                            console.log(currentnode);
                            this.printGraph();
                            break;
                        }
                    } else {
                        counter.set(currentnode, 1)
                    }
                    let currentDepth = distance.get(currentnode);
                    G.get(currentnode).forEach(node => {
                        if (!distance.has(node) || distance.get(node) < currentDepth + 1) {
                            distance.set(node, currentDepth + 1);
                            nodes_to_visit.unshift(node);
                        }
                    })

                }
            }
        }
        function wallsToGraph(w) {
            if (w.length < 2) return [];

            const g = new Graph();
            for (let i = 0; i < w.length - 1; i++) {
                for (let j = i + 1; j < w.length; j++) {
                    if (v1HigherThanv2(w[i], w[j])) {
                        g.addEdge(j, i);
                    } else if (v1HigherThanv2(w[j], w[i])) {
                        g.addEdge(i, j);
                    } else {
                        g.addVertex(i);
                        g.addVertex(j);
                    }
                }
            }

            g.printGraph();
            let final = g.topologicalSort().reverse()

            return final;
        }

        // returns true if v1 is higher than v2
        function v1HigherThanv2(w1, w2) {

            const W1p = {
                "x": player.pos.x + w1.p.dist * w1.p.x,
                "y": player.pos.y + w1.p.dist * w1.p.y
            }
            const W1h = {
                "x": player.pos.x + w1.h.dist * w1.h.x,
                "y": player.pos.y + w1.h.dist * w1.h.y
            }
            const W2p = {
                "x": player.pos.x + w2.p.dist * w2.p.x,
                "y": player.pos.y + w2.p.dist * w2.p.y
            }
            const W2h = {
                "x": player.pos.x + w2.h.dist * w2.h.x,
                "y": player.pos.y + w2.h.dist * w2.h.y
            }

            // V2 Just the wall vector (v1header - v1pos)
            // Creating the vector is different so that we can check for intersections
            const W2ptoW2h = {
                "pos": {
                    "x": player.pos.x + w2.p.x * w2.p.dist,
                    "y": player.pos.y + w2.p.y * w2.p.dist
                },
                "header": {
                    "x": w2.h.x * w2.h.dist - w2.p.x * w2.p.dist,
                    "y": w2.h.y * w2.h.dist - w2.p.y * w2.p.dist
                }
            };

            const PltoW1P = {
                "pos": {
                    "x": player.pos.x,
                    "y": player.pos.y
                },
                "header": {
                    "x": w1.p.x * w1.p.dist,
                    "y": w1.p.y * w1.p.dist
                }
            };
            const PltoW1H = {
                "pos": {
                    "x": player.pos.x,
                    "y": player.pos.y
                },
                "header": {
                    "x": w1.h.x * w1.h.dist,
                    "y": w1.h.y * w1.h.dist
                }
            };

            return isIntersectionVectors(PltoW1P, W2ptoW2h) || isIntersectionVectors(PltoW1H, W2ptoW2h) ||
                ptInTriangle(W2p, player.pos, W1p, W1h) || ptInTriangle(W2h, player.pos, W1p, W1h)
        }

        function ptInTriangle(p, p0, p1, p2) {
            var A = 1 / 2 * (-p1.y * p2.x + p0.y * (-p1.x + p2.x) + p0.x * (p1.y - p2.y) + p1.x * p2.y);
            var sign = A < 0 ? -1 : 1;
            var s = (p0.y * p2.x - p0.x * p2.y + (p2.y - p0.y) * p.x + (p0.x - p2.x) * p.y) * sign;
            var t = (p0.x * p1.y - p0.y * p1.x + (p0.y - p1.y) * p.x + (p1.x - p0.x) * p.y) * sign;

            return s > 0.0 && t > 0.0 && (s + t) < 2.0 * A * sign;
        }
        // Canvas declared in interface.js
        handlers.updateCanvasSize();
        ctx.translate(0, canvas.height);
        ctx.scale(1, -1);

        ctx2D.translate(0, canvas2D.height);
        ctx2D.scale(1, -1);

        const player = new Player(canvas2D.width / 2, canvas2D.height - canvas2D.height / 1.4, 90);
        player.fov.xamount = 90;

        player.setFOV();

        let wallCount = 0
        const walls = [];
        let renderWalls = [];

        let showGraph = false;

        // let tmp = ""
        // walls.forEach(w => {
        //     tmp = tmp + "walls.push(new Boundary(" + w.pos.x + ", " + w.pos.y + ", " +
        //                                         (w.pos.x + w.header.x) + ", " + (w.pos.y + w.header.y) + ", " + w.hue + "));\n"
        // });
        // console.log(tmp);

        function exampleScene() {
            renderWalls.splice(0, renderWalls.length);
            wallCount = 0;
            walls.splice(0, walls.length);
            walls.push(new Boundary(430, canvas2D.height - 270, 530, canvas2D.height - 270));
            walls.push(new Boundary(339, canvas2D.height - 118, 232, canvas2D.height - 192));
            walls.push(new Boundary(157, canvas2D.height - 197, 113, canvas2D.height - 387));
            walls.push(new Boundary(201, canvas2D.height - 417, 289, canvas2D.height - 321));
            walls.push(new Boundary(354, canvas2D.height - 427, 488, canvas2D.height - 495));
            walls.push(new Boundary(615, canvas2D.height - 464, 702, canvas2D.height - 417));
            walls.push(new Boundary(790, canvas2D.height - 200, 694, canvas2D.height - 59));
            walls.push(new Boundary(429, canvas2D.height - 20, 304, canvas2D.height - 32));
            walls.push(new Boundary(148, canvas2D.height - 58, 39, canvas2D.height - 95));
            walls.push(new Boundary(488, canvas2D.height - 115, 613, canvas2D.height - 157));
            walls.push(new Boundary(912, canvas2D.height - 251, 931, canvas2D.height - 409));
            walls.push(new Boundary(762, canvas2D.height - 345, 815, canvas2D.height - 472));
        }

        exampleScene();

        let show2D = true;
        let show2D2 = false;
        let showWallNums = false;
        let rainbowMode = false;

        gameLoop();
        function gameLoop() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx2D.clearRect(0, 0, canvas2D.width, canvas2D.height);



            background();
            playerHandler.movement();
            set2Dctx();
            player.draw();
            set3Dctx();
            renderWalls.splice(0, renderWalls.length)
            walls.forEach(wall => {
                if (rainbowMode) {
                    if (wall.hue >= 255) wall.hue = -1;
                    wall.hue += 1;
                }
                if (show2D) {
                    set2Dctx();
                    wall.draw();
                }
                if (wall.isInsideFOV()) {
                    wall.processFOV();
                    wall.calculate3D();
                    renderWalls.push(wall);
                }
            });

            if (renderWalls.length >= 1) {
                let sorted = wallsToGraph(renderWalls);
                if (sorted.length <= 1) sorted = [0]
                sorted.forEach(index => {
                    renderWalls[index].display3D();
                });
            }

            drawing.start();
            touchControls();

            requestAnimationFrame(gameLoop);
        }

        // background terrain
        function background() {
            // ctx.fillStyle = '#00d2ff';
            ctx.fillStyle = "#64a7ff";
            ctx.fillRect(0, canvas.height / 2, canvas.width, canvas.height);
            ctx.fillStyle = "#969696";
            ctx.fillRect(0, -canvas.height / 2, canvas.width, canvas.height);

            ctx2D.fillStyle = 'gray';
            ctx2D.fillRect(0, 0, canvas2D.width, canvas2D.height);

        }
    </script>
</body>
</html>
